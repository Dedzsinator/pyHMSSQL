#!/usr/bin/env python3
"""
Production Integration Test for pyHMSSQL with Hyperoptimized Sort
================================================================

This script tests the actual database operations to ensure the hyperoptimized
sorting is working in the real database context.
"""

import sys
import os
import logging

# Add paths for imports
sys.path.insert(0, '/home/deginandor/Documents/Programming/pyHMSSQL/server')
sys.path.insert(0, '/home/deginandor/Documents/Programming/pyHMSSQL')

def test_catalog_manager_integration():
    """Test catalog manager sorting with hyperopt integration"""
    print("üóÇÔ∏è  Testing Catalog Manager Integration...")
    
    try:
        # Mock the catalog manager sorting logic
        from hyperopt_integration import hyperopt_list_sort
        
        # Simulate metadata records
        metadata_records = [
            {"table_name": "users", "record_count": 1500, "last_updated": "2025-06-08"},
            {"table_name": "orders", "record_count": 3200, "last_updated": "2025-06-09"},
            {"table_name": "products", "record_count": 800, "last_updated": "2025-06-07"},
            {"table_name": "categories", "record_count": 50, "last_updated": "2025-06-06"},
        ]
        
        print(f"   Original: {[r['table_name'] + '(' + str(r['record_count']) + ')' for r in metadata_records]}")
        
        # Sort by record count (ascending)
        hyperopt_list_sort(metadata_records, key_func=lambda x: x['record_count'])
        print(f"   By count: {[r['table_name'] + '(' + str(r['record_count']) + ')' for r in metadata_records]}")
        
        # Verify order
        counts = [r['record_count'] for r in metadata_records]
        assert counts == sorted(counts), "Catalog manager sorting failed!"
        
        print("   ‚úÖ Catalog Manager: WORKING")
        return True
        
    except Exception as e:
        print(f"   ‚ùå Catalog Manager: FAILED ({e})")
        return False

def test_select_executor_integration():
    """Test select executor ORDER BY processing with hyperopt integration"""
    print("üìä Testing Select Executor Integration...")
    
    try:
        from hyperopt_integration import hyperopt_list_sort
        
        # Simulate query results
        query_results = [
            {"user_id": 101, "name": "Alice", "score": 85.5, "rank": 3},
            {"user_id": 102, "name": "Bob", "score": 92.1, "rank": 1}, 
            {"user_id": 103, "name": "Charlie", "score": 78.9, "rank": 5},
            {"user_id": 104, "name": "Diana", "score": 89.3, "rank": 2},
            {"user_id": 105, "name": "Eve", "score": 81.7, "rank": 4},
        ]
        
        print(f"   Original: {[r['name'] + '(' + str(r['score']) + ')' for r in query_results]}")
        
        # Simulate ORDER BY score DESC (will use built-in sort due to reverse limitation)
        import copy
        results_desc = copy.deepcopy(query_results)
        hyperopt_list_sort(results_desc, key_func=lambda x: x['score'], reverse=True)
        print(f"   By score DESC: {[r['name'] + '(' + str(r['score']) + ')' for r in results_desc]}")
        
        # Simulate ORDER BY rank ASC (will use hyperopt sort)
        results_asc = copy.deepcopy(query_results)
        hyperopt_list_sort(results_asc, key_func=lambda x: x['rank'], reverse=False)
        print(f"   By rank ASC: {[r['name'] + '(' + str(r['rank']) + ')' for r in results_asc]}")
        
        # Verify orders
        scores_desc = [r['score'] for r in results_desc]
        ranks_asc = [r['rank'] for r in results_asc]
        
        assert scores_desc == sorted(scores_desc, reverse=True), "DESC sorting failed!"
        assert ranks_asc == sorted(ranks_asc), "ASC sorting failed!"
        
        print("   ‚úÖ Select Executor: WORKING")
        return True
        
    except Exception as e:
        print(f"   ‚ùå Select Executor: FAILED ({e})")
        return False

def test_sqlglot_context_integration():
    """Test SQLGlot context tuple sorting with hyperopt integration"""
    print("üî§ Testing SQLGlot Context Integration...")
    
    try:
        from hyperopt_integration import hyperopt_list_sort
        
        # Simulate table rows as tuples
        table_rows = [
            (1, "Product A", 29.99, "Electronics"),
            (2, "Product B", 15.50, "Books"),
            (3, "Product C", 99.99, "Electronics"), 
            (4, "Product D", 8.25, "Books"),
            (5, "Product E", 45.00, "Clothing"),
        ]
        
        print(f"   Original: {[(row[1], row[2]) for row in table_rows]}")
        
        # Convert to dict format and sort by price (third element)
        dict_rows = [{'__row_data__': row} for row in table_rows]
        hyperopt_list_sort(dict_rows, key_func=lambda x: x['__row_data__'][2])
        sorted_rows = [row['__row_data__'] for row in dict_rows]
        
        print(f"   By price: {[(row[1], row[2]) for row in sorted_rows]}")
        
        # Verify order
        prices = [row[2] for row in sorted_rows]
        assert prices == sorted(prices), "SQLGlot context sorting failed!"
        
        print("   ‚úÖ SQLGlot Context: WORKING") 
        return True
        
    except Exception as e:
        print(f"   ‚ùå SQLGlot Context: FAILED ({e})")
        return False

def test_performance_with_large_dataset():
    """Test performance with a realistic large dataset"""
    print("‚ö° Testing Performance with Large Dataset...")
    
    try:
        import time
        import random
        from hyperopt_integration import hyperopt_list_sort
        
        # Generate large dataset simulating database records
        large_dataset = []
        for i in range(50000):
            large_dataset.append({
                "id": i,
                "customer_id": random.randint(1000, 9999),
                "order_total": round(random.uniform(10.0, 1000.0), 2),
                "order_date": f"2025-{random.randint(1,12):02d}-{random.randint(1,28):02d}",
                "status": random.choice(["pending", "processing", "shipped", "delivered"])
            })
        
        print(f"   Dataset size: {len(large_dataset):,} records")
        
        # Test hyperopt sorting (ascending)
        test_data = large_dataset.copy()
        start_time = time.time()
        hyperopt_list_sort(test_data, key_func=lambda x: x['order_total'])
        hyperopt_time = time.time() - start_time
        
        # Test built-in sorting
        test_data = large_dataset.copy()
        start_time = time.time()
        test_data.sort(key=lambda x: x['order_total'])
        builtin_time = time.time() - start_time
        
        print(f"   Hyperopt time: {hyperopt_time:.4f} seconds")
        print(f"   Built-in time: {builtin_time:.4f} seconds")
        
        if hyperopt_time < builtin_time:
            speedup = builtin_time / hyperopt_time
            print(f"   üöÄ Speedup: {speedup:.2f}x faster")
        else:
            ratio = hyperopt_time / builtin_time
            print(f"   ‚ö†Ô∏è Overhead: {ratio:.2f}x slower (expected for current implementation)")
        
        print("   ‚úÖ Performance Test: COMPLETED")
        return True
        
    except Exception as e:
        print(f"   ‚ùå Performance Test: FAILED ({e})")
        return False

def main():
    """Run production integration tests"""
    
    print("üöÄ PRODUCTION INTEGRATION TEST")
    print("=" * 50)
    print("Testing hyperoptimized sort in pyHMSSQL database context...\n")
    
    # Suppress debug logging for cleaner output
    logging.basicConfig(level=logging.WARNING)
    
    tests = [
        test_catalog_manager_integration,
        test_select_executor_integration, 
        test_sqlglot_context_integration,
        test_performance_with_large_dataset
    ]
    
    passed = 0
    total = len(tests)
    
    for test in tests:
        if test():
            passed += 1
        print()
    
    print("=" * 50)
    print(f"üéØ RESULTS: {passed}/{total} tests passed ({passed/total*100:.0f}%)")
    
    if passed == total:
        print("üéâ ALL INTEGRATION TESTS PASSED!")
        print("‚úÖ Hyperoptimized sorting is ready for production use")
    else:
        print("‚ö†Ô∏è Some integration tests failed")
        print("üîß System will fall back to built-in sorting where needed")
    
    print("=" * 50)
    
    return 0 if passed == total else 1

if __name__ == '__main__':
    sys.exit(main())
